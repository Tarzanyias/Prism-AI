<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prism AI</title>
    <link rel="icon" type="image/png" href="Images/Logo 1.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for chat layout and responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            background-color: #f8fafc;
        }
        header {
            text-align: center;
            padding: 1.25rem;
            background-color: #ffffff;
            border-bottom: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
        }
        main {
            flex-grow: 1;
            padding: 1.25rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            max-width: 800px;
            margin: 0 auto;
        }
        .message-container {
            display: flex;
        }
        .message-container.user {
            justify-content: flex-end;
        }
        .message-container.ai {
            justify-content: flex-start;
        }
        .message {
            max-width: 75%;
            padding: 0.75rem 1rem;
            border-radius: 1.25rem;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }
        .message.user {
            background-color: #dbeafe;
            color: #1e293b;
            border-bottom-right-radius: 0.25rem;
        }
        .message.ai {
            background-color: #ffffff;
            color: #1e293b;
            border-bottom-left-radius: 0.25rem;
        }
        /* New style for the image placeholder/display */
        .ai-image-output {
            padding: 0; /* Remove padding for image box */
            display: block;
            max-width: 100%;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .ai-image-output img {
            width: 100%; /* Image takes full width of the message container */
            border-radius: 1.25rem; /* Match message container rounded corners */
            border-bottom-left-radius: 0.25rem;
            display: block;
        }
        /* (Other styles truncated for brevity but remain the same) */
        footer {
            padding: 1rem;
            background-color: #ffffff;
            border-top: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);
        }
        #questionInput {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }
        #questionInput:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
        }
        #sendButton {
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        #sendButton:hover {
            background-color: #2563eb;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #sendButton:disabled {
            background-color: #93c5fd;
            cursor: not-allowed;
            box-shadow: none;
        }
        .ai-loading-gif {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
            margin-right: 0.25rem;
        }
        .header-logo {
            height: 40px;
            width: auto;
            margin-right: 0.5rem;
        }
        .message ul {
            list-style-type: disc;
            margin-left: 1.25rem;
            padding-left: 0;
        }
        .message ol {
            list-style-type: decimal;
            margin-left: 1.25rem;
            padding-left: 0;
        }
        .message pre {
            background-color: #e2e8f0;
            padding: 0.75rem;
            border-radius: 0.375rem;
            overflow-x: auto;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .message code {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            background-color: #e2e8f0;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
        }
        @media (max-width: 640px) {
            main {
                padding: 0.75rem;
                max-width: 100%;
            }
            .message {
                max-width: 90%;
            }
            footer {
                flex-direction: column;
                padding: 0.75rem;
                gap: 0.5rem;
            }
            #questionInput {
                width: 100%;
            }
            #sendButton {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <img src="Images/Logo.png" alt="Prism AI Logo" class="header-logo">
        <h1 class="text-3xl font-bold text-gray-800">Prism AI</h1>
    </header>

    <main id="chatHistory" class="flex flex-col flex-grow p-5 overflow-y-auto gap-3 max-w-4xl mx-auto">
        </main>

    <footer class="flex items-center p-4 bg-white border-t border-slate-200 shadow-sm">
        <input
            type="text"
            id="questionInput"
            placeholder="Ask or tell Prism AI to generate an image..."
            class="flex-grow py-3 px-4 border border-slate-300 rounded-lg text-base outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-500/25"
        >
        <button
            id="sendButton"
            class="py-3 px-6 bg-blue-500 text-white rounded-lg font-medium cursor-pointer transition-colors duration-200 hover:bg-blue-600 shadow-md disabled:bg-blue-300 disabled:cursor-not-allowed"
        >
            Send
        </button>
    </footer>

    <script>
        const questionInput = document.getElementById('questionInput');
        const sendButton = document.getElementById('sendButton');
        const chatHistory = document.getElementById('chatHistory');

        // WARNING: API Key is exposed in client-side code. Use a backend proxy in production.
        const apiKey = "AIzaSyCoWMv5gNMdKivP95Qm085K_51EtuhPwO0";
        const textApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        
        // This is a simulated base64 image (small JPEG of a simple cat icon)
        const SIMULATED_IMAGE_BASE64 = '/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgAAgAAAAAAAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAAgACADASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAD/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AqgDkAAf/Z';

        let chatHistoryForApi = [
            { role: "user", parts: [{ text: "What is the capital of France?" }] },
            { role: "model", parts: [{ text: "The capital of France is Paris." }] },
            { role: "model", parts: [{ text: "Hello! I am Prism AI. How can I assist you today?" }] }
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const initialAiMessage = chatHistoryForApi[chatHistoryForApi.length - 1].parts[0].text;
            const messageContainer = document.createElement('div');
            messageContainer.classList.add('message-container', 'ai', 'flex');
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'ai', 'max-w-3/4', 'py-3', 'px-4', 'rounded-2xl', 'rounded-bl-sm', 'shadow-sm', 'word-wrap');
            messageDiv.innerHTML = formatText(initialAiMessage);
            messageContainer.appendChild(messageDiv);
            chatHistory.appendChild(messageContainer);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        });

        // (The formatText function remains the same as your original code)
        function formatText(text) {
             let formattedText = text;
             // 1. Escape HTML entities first
             formattedText = formattedText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');

             const codeBlockPlaceholders = [];
             formattedText = formattedText.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
                 const placeholder = `__CODE_BLOCK_${codeBlockPlaceholders.length}__`;
                 // Re-escape angle brackets within code content for <pre> tags
                 const escapedContent = codeContent.trim().replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
                 codeBlockPlaceholders.push(`<pre>${escapedContent}</pre>`);
                 return placeholder;
             });
             formattedText = formattedText.replace(/`(.*?)`/g, '<code>$1</code>');
             formattedText = formattedText.replace(/\*\*(.*?)\*\*|__(.*?)__/g, '<strong>$1$2</strong>');
             formattedText = formattedText.replace(/\*(.*?)\*|_(.*?)_/g, '<em>$1$2</em>');
             
             // List handling
             formattedText = formattedText.replace(/(?:^|\n)([\s]*[\*\-]\s.*(?:\n[\s]*[\*\-]\s.*)*)/gm, (match, listContent) => {
                 const listItems = listContent.trim().split('\n').map(line => `<li>${line.replace(/^[\s]*[\*\-]\s/, '').trim()}</li>`).join('');
                 return `<ul>${listItems}</ul>`;
             });
             formattedText = formattedText.replace(/(?:^|\n)([\s]*\d+\.\s.*(?:\n[\s]*\d+\.\s.*)*)/gm, (match, listContent) => {
                 const listItems = listContent.trim().split('\n').map(line => `<li>${line.replace(/^[\s]*\d+\.\s/, '').trim()}</li>`).join('');
                 return `<ol>${listItems}</ol>`;
             });

             // Paragraph and line break handling
             const finalLines = formattedText.split('\n');
             let outputHtml = [];
             let currentParagraph = [];
             for (const line of finalLines) {
                 const trimmedLine = line.trim();
                 const isBlockElementStart = trimmedLine.startsWith('<ul') || trimmedLine.startsWith('<ol') || trimmedLine.startsWith('<pre>') || trimmedLine.startsWith('__CODE_BLOCK_');
                 if (trimmedLine === '') {
                     if (currentParagraph.length > 0) {
                         outputHtml.push(`<p>${currentParagraph.join('<br>')}</p>`);
                         currentParagraph = [];
                     }
                 } else if (isBlockElementStart) {
                     if (currentParagraph.length > 0) {
                         outputHtml.push(`<p>${currentParagraph.join('<br>')}</p>`);
                         currentParagraph = [];
                     }
                     outputHtml.push(trimmedLine);
                 } else {
                     currentParagraph.push(trimmedLine);
                 }
             }
             if (currentParagraph.length > 0) {
                 outputHtml.push(`<p>${currentParagraph.join('<br>')}</p>`);
             }

             formattedText = outputHtml.join('');
             codeBlockPlaceholders.forEach((codeBlock, index) => {
                 formattedText = formattedText.replace(`__CODE_BLOCK_${index}__`, codeBlock);
             });
             formattedText = formattedText.replace(/<p>\s*<\/p>/g, '');
             return formattedText;
         }


        /**
         * Types out text content character by character into a given DOM element.
         * Applies formatting after typing is complete.
         */
        function typeTextContent(element, text) {
            return new Promise(resolve => {
                let currentTypedText = '';
                let index = 0;
                const typingSpeed = 20; // milliseconds per character

                function typeCharacter() {
                    if (index < text.length) {
                        currentTypedText += text.charAt(index);
                        element.textContent = currentTypedText; 
                        index++;
                        chatHistory.scrollTop = chatHistory.scrollHeight;
                        setTimeout(typeCharacter, typingSpeed);
                    } else {
                        element.innerHTML = formatText(text);
                        chatHistory.scrollTop = chatHistory.scrollHeight;
                        resolve();
                    }
                }
                typeCharacter();
            });
        }
        
        // (The appendMessage function remains the same as your original code)
        function appendMessage(content, sender) {
            return new Promise(async resolve => {
                const messageContainer = document.createElement('div');
                messageContainer.classList.add('message-container', sender, 'flex');
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message', sender, 'max-w-3/4', 'py-3', 'px-4', 'rounded-2xl', 'shadow-sm', 'word-wrap');

                if (sender === 'user') {
                    messageDiv.classList.add('bg-blue-100', 'text-slate-800', 'rounded-br-sm');
                    messageDiv.textContent = content;
                    messageContainer.appendChild(messageDiv);
                    chatHistory.appendChild(messageContainer);
                    chatHistory.scrollTop = chatHistory.scrollHeight;
                    resolve();
                } else {
                    messageDiv.classList.add('bg-white', 'text-slate-800', 'rounded-bl-sm');
                    const loadingGif = document.createElement('img');
                    loadingGif.src = 'Loading.gif';
                    loadingGif.alt = 'Loading...';
                    loadingGif.classList.add('ai-loading-gif');
                    messageDiv.appendChild(loadingGif);
                    const typedTextContentDiv = document.createElement('div');
                    typedTextContentDiv.classList.add('typed-text-content');
                    messageDiv.appendChild(typedTextContentDiv);
                    messageContainer.appendChild(messageDiv);
                    chatHistory.appendChild(messageContainer);
                    chatHistory.scrollTop = chatHistory.scrollHeight;

                    if (Array.isArray(content)) {
                        for (const part of content) {
                            if (part.text) {
                                if (loadingGif.parentNode) { loadingGif.remove(); }
                                await typeTextContent(typedTextContentDiv, part.text);
                            }
                        }
                    } else if (typeof content === 'string') {
                        if (loadingGif.parentNode) { loadingGif.remove(); }
                        await typeTextContent(typedTextContentDiv, content);
                    }

                    if (loadingGif.parentNode) { loadingGif.remove(); }
                    chatHistory.scrollTop = chatHistory.scrollHeight;
                    resolve();
                }
            });
        }


        /**
         * NEW FUNCTION: Appends a base64 encoded image to the chat history.
         */
        function appendImageMessage(base64Image, sender) {
            return new Promise(resolve => {
                const messageContainer = document.createElement('div');
                messageContainer.classList.add('message-container', sender, 'flex');

                const imageDiv = document.createElement('div');
                imageDiv.classList.add('message', sender, 'ai-image-output', 'max-w-3/4', 'rounded-2xl', 'rounded-bl-sm');
                imageDiv.style.padding = '0'; // Ensure the image fills the space

                const imgElement = document.createElement('img');
                imgElement.src = `data:image/jpeg;base64,${base64Image}`; // Use JPEG mime type for the simulated image
                imgElement.alt = "Generated Image";

                imageDiv.appendChild(imgElement);
                messageContainer.appendChild(imageDiv);
                chatHistory.appendChild(messageContainer);
                chatHistory.scrollTop = chatHistory.scrollHeight;
                resolve();
            });
        }

        /**
         * Handles sending a message to the AI, now supporting both text and image generation.
         */
        async function handleSendMessage() {
            const question = questionInput.value.trim();
            if (!question) {
                return;
            }

            await appendMessage(question, 'user');
            questionInput.value = '';

            const isImageRequest = question.toLowerCase().startsWith('generate image of') || 
                                   question.toLowerCase().startsWith('draw') ||
                                   question.toLowerCase().startsWith('create a picture of');
            
            // Disable button and input immediately
            sendButton.disabled = true;
            questionInput.disabled = true;

            try {
                if (isImageRequest) {
                    // --- ðŸ–¼ï¸ IMAGE GENERATION LOGIC (SIMULATED) ---
                    const prompt = question.replace(/generate image of|draw|create a picture of/i, '').trim();

                    await appendMessage([{ text: `Generating image for prompt: **${prompt}**...` }], 'ai');
                    
                    // SIMULATION: Wait for 3 seconds to simulate API call time
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    // SIMULATION: Display the placeholder image
                    await appendImageMessage(SIMULATED_IMAGE_BASE64, 'ai');

                    // NO final text message here, simulating a successful image display being the final response.
                    
                } else {
                    // --- ðŸ’¬ TEXT CHAT LOGIC (ORIGINAL) ---
                    
                    // 1. Add user's message to the history ONLY for text requests
                    chatHistoryForApi.push({ role: "user", parts: [{ text: question }] });
                    
                    let aiResponseText;

                    if (question.toLowerCase() === "what ai are you") {
                        aiResponseText = "I am Prism AI developed and trained by a private third party.";
                        await appendMessage(aiResponseText, 'ai');
                        chatHistoryForApi.push({ role: "model", parts: [{ text: aiResponseText }] });
                    } else {
                        const payload = { contents: chatHistoryForApi };
                        const response = await fetch(textApiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            chatHistoryForApi.pop(); 
                            throw new Error('Could not get a response from AI.');
                        }

                        const result = await response.json();
                        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts) {
                            const aiContentParts = result.candidates[0].content.parts;
                            await appendMessage(aiContentParts, 'ai'); 
                            chatHistoryForApi.push({ role: "model", parts: aiContentParts });
                        } else {
                            chatHistoryForApi.pop();
                            throw new Error("Unexpected AI response structure.");
                        }
                    }
                }
            } catch (error) {
                console.error('Operation Error:', error);
                await appendMessage("Error: Something went wrong. " + error.message, 'ai');

            } finally {
                sendButton.disabled = false;
                questionInput.disabled = false;
                questionInput.focus();
            }
        }

        // Event listeners for sending messages
        sendButton.addEventListener('click', handleSendMessage);
        questionInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                handleSendMessage();
            }
        });
    </script>
</body>
</html>
